#Q1
//	Write a program to implement the shell. It should display the commandprompt “myshell$”
// Tokenize the command line and execute the given command by creating the child process.
// Additionally it should interpret the following ‘list’ commands as

// myshell$ list f dirname    :- To print names of all the files in current directory.
// myshell$ list n dirname  :- To print the number of all entries in the current directory.
// myshell$ list i dirname : To print names and inodes of the files in the current directory.

#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <dirent.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/wait.h>

void make_toks(char *s, char *tok[])
{
  int i = 0;
  char *p;
  p = strtok(s, " ");
  while (p != NULL)
  {
    tok[i++] = p;
    p = strtok(NULL, " ");
  }
  tok[i] = NULL;
}

void list(char *dn, char op)
{
  DIR *dp;
  struct dirent *entry;
  int dc = 0, fc = 0;
  dp = opendir(dn);
  if (dp == NULL)
  {
    printf("Dir %s not found.\n", dn);
    return;
  }
  switch (op)
  {
  case 'f':
    while (entry = readdir(dp))
      if (entry->d_type == DT_REG)
        printf("%s\n", entry->d_name);
    break;
  case 'n':
    while (entry = readdir(dp))
    {
      if (entry->d_type == DT_DIR)
        dc++;
      if (entry->d_type == DT_REG)
        fc++;
    }
    printf("%d Dir(s)\t%d File(s)\n", dc, fc);
    break;
  case 'i':
    while (entry = readdir(dp))
      if (entry->d_type == DT_REG)
        printf("%s\t%d\n", entry->d_name, entry->d_fileno);
  }
  closedir(dp);
}

int main()
{
  char buff[80], *args[10];
  int pid;
  int status;
  while (1)
  {
    printf("myshell$ ");
    fflush(stdin);
    fgets(buff, 80, stdin);
    buff[strlen(buff) - 1] = '\0';
    make_toks(buff, args);
    if (strcmp(args[0], "list") == 0)
      list(args[2], args[1][0]);
    else
    {
      pid = fork();
      if (pid > 0)
        wait(&status);
      else
        if (execvp(args[0], args) == -1)
          printf("Bad command.\n");
    }
  }
  return 0;
}



#Q2
#include <stdio.h>
#include <stdlib.h>

typedef struct process
{
  int id, at, bt, ct , wt, tat, rt;
} process;
void display(process pro[], int n)
{
	printf("P  AT BT CT TAT WT  \n");
	for (int i = 0; i < n; i++)
	{
		printf("P%d %2d %2d %2d %2d %2d\n",
				pro[i].id,
				pro[i].at,
				pro[i].bt,
				pro[i].ct,
				pro[i].tat,
				pro[i].wt);
	}
}
void preemptiveSJF(process proc[], int n, int tq)
{
  int i = 0;
  int time = 0;
  int p = n;
  while(p > 0) {
	  int min = -1;
	  for(i = 0; i < n;i++) {
		  if(proc[i].at <= time && proc[i].rt > 0) {
			  if(min == -1 || proc[i].rt < proc[min].rt) {
				  min = i;
			  }
		  }
	  }
	  if(min == -1) time++;
	  else if(proc[min].rt <= tq) {
		  time += proc[min].rt;
		  proc[min].rt = 0;
		  proc[min].ct = time;
		  p--;
	  } else {
		  proc[min].rt -= tq;
		  time += tq;
	  }
  }
  int ttat = 0;
  int twt = 0; 
  for(i = 0; i < n; i++) {
	  proc[i].tat = proc[i].ct - proc[i].at;
	  proc[i].wt = proc[i].tat - proc[i].bt; 
	  ttat += proc[i].tat;
	  twt += proc[i].wt;
  }
  display(proc, n);
  printf("Average TAT: %.2f\nAverage WT: %.2f\n" , (ttat * 1.0) / n , (twt * 1.0) / n);
}

int main()
{
  process proc[10];
  int n, i, tq;
  printf("Enter number of processes: ");
  scanf(" %d", &n);
  for (i = 0; i < n; i++)
  {
    printf("\n");
    printf("Arrival time for P%d: ", i + 1);
    scanf(" %d", &proc[i].at);
    printf("Burst time for P%d: ", i + 1);
    scanf(" %d", &proc[i].bt);
    proc[i].rt = proc[i].bt;
	proc[i].ct = proc[i].tat = proc[i].wt = 0;
    proc[i].id = i + 1;
  }
  printf("Enter time quantum for preemption: ");
  scanf(" %d", &tq);
  preemptiveSJF(proc, n, tq);
  return 0;
}