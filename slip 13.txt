#Q1
// Write a C program to implement the shell which displays the command prompt “myshell$”.
// It accepts the command, tokenize the command line and execute it by creating the child process.

// Also implement the additional command ‘typeline’ as

//  typeline +n filename :- To print first n lines in the file.
//  typeline -n filename :- To print last n lines in the file.
//  typeline a filename :- To print all lines in the file.

#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>

void make_toks(char *s, char *tok[])
{
  int i = 0;
  char *p;
  p = strtok(s, " ");
  while (p != NULL)
  {
    tok[i++] = p;
    p = strtok(NULL, " ");
  }
  tok[i] = NULL;
}

void typeline(char *fn, char *op)
{
  int fh, i, j, n;
  char c;
  fh = open(fn, O_RDONLY);
  if (fh == -1)
  {
    printf("File %s not found.\n", fn);
    return;
  }
  if (strcmp(op, "a") == 0)
  {
    while (read(fh, &c, 1) > 0)
      printf("%c", c);
    close(fh);
    return;
  }
  n = atoi(op);
  if (n > 0)
  {
    i = 0;
    while (read(fh, &c, 1) > 0)
    {
      printf("%c", c);
      if (c == '\n')
        i++;
      if (i == n)
        break;
    }
  }
  if (n < 0)
  {
    i = 0;
    while (read(fh, &c, 1) > 0)
      if (c == '\n')
        i++;
    lseek(fh, 0, SEEK_SET);
    j = 0;
    while (read(fh, &c, 1) > 0)
    {
      if (c == '\n')
        j++;
      if (j == i + n)
        break;
    }
    while (read(fh, &c, 1) > 0)
      printf("%c", c);
  }
  close(fh);
}

int main()
{
  char buff[80], *args[10];
  int pid , status;
  while (1)
  {
    printf("myshell$ ");
    fflush(stdin);
    fgets(buff, 80, stdin);
    buff[strlen(buff) - 1] = '\0';
    make_toks(buff, args);
    if (strcmp(args[0], "typeline") == 0)
      typeline(args[2], args[1]);
    else
    {
      pid = fork();
      if (pid > 0)
        wait(&status);
      else
        if (execvp(args[0], args) == -1)
          printf("Bad command.\n");
    }
  }

  return 0;
}


#Q2
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct process {
	int id  , at , bt , ct , tat, wt , rt;
} process;

typedef struct queue {
	int pro;
} queue;

queue root[50];

int front = 0;
int rare = 0;

void push(int id) {
	root[rare].pro = id;
	rare++;
}

int pop() {
	if(front == rare) return -1;
	int temp = root[front].pro;
	front++;
	return temp;
}

int isEmpty() {
	if(front == rare) return 1;
	return 0;
}

void sortAT(process pro[], int n)
{
	process temp;
	for(int i = 0; i < n; i++)
		for(int j = 0; j < n - i - 1; j++)
			if(pro[j].at > pro[j + 1].at)
			{
				temp = pro[j];
				pro[j] = pro[j + 1];
				pro[j + 1] = temp;
			}
}

void display(process pro[], int n)
{
	printf("\n\nTABLE:\n");
	for (int i = 0; i < n; i++)
	{
		printf("P%d AT: %d BT: %d CT: %d TAT: %d WT: %d\n",
				pro[i].id,
				pro[i].at,
				pro[i].bt,
				pro[i].ct,
				pro[i].tat,
				pro[i].wt);
	}
}

void roundrobin(process proc[], int n, int time_quantom) {
	sortAT(proc , n);
	int i , currTime = 0;
	for(i = 0; i < n;) {
		if(proc[i].at <= currTime && proc[i].rt > 0) {
			if(proc[i].rt < time_quantom) {
				currTime += proc[i].rt;
				proc[i].rt = 0;
				proc[i].ct = currTime;
			} else {
				proc[i].rt -= time_quantom;
				currTime += time_quantom;
				if(proc[i].rt > 0)
					push(proc[i].id);
				else {
					proc[i].ct = currTime;
				}
			}
			i++;
		} else currTime++;
	}

	while(!isEmpty()) {
		int curr = pop();
		int find = 0;
		while(find < n) {
			if(proc[find].id == curr) {
				break;
			}
			find++;
		}
		curr = find;
		if(proc[curr].rt < time_quantom) {  
			currTime += proc[curr].rt;
			proc[curr].rt = 0;
			proc[curr].ct = currTime;
		} else {
			proc[curr].rt -= time_quantom;
			currTime += time_quantom;
			proc[curr].ct = currTime;
			if(proc[curr].rt > 0)
				push(proc[curr].id);
		}
	}

	double twt = 0;
	double ttat = 0;

	for(i = 0; i < n; i++) {
		proc[i].tat = proc[i].ct - proc[i].at;
		proc[i].wt = proc[i].tat - proc[i].bt;
		twt += proc[i].wt;
		ttat = proc[i].tat;
	}

	printf("\n");
	display(proc , n);
	printf("\nAvg waiting time: %.2f\nAvg turnaround time: %.2f\n\n", twt / n, ttat / n);
}


int main() {
	int n = 4;
	printf("Enter number of processes: ");
	scanf(" %d" , &n);
	process pro[n];
	int i = 0;
	for(i = 0; i < n; i++) {
		pro[i].id = i+1;
		printf("Enter AT: ");
		scanf(" %d" , &pro[i].at);
		printf("Enter BT: ");
		scanf(" %d" , &pro[i].bt);
		pro[i].rt = pro[i].bt;
		pro[i].ct = pro[i].wt = pro[i].tat = 0;
	}
	int tq;
	printf("Enter time quantom: ");
	scanf(" %d" , &tq);
	roundrobin(pro , n , tq);
}
  