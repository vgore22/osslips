#Q1
#include <stdio.h>
#include <stdlib.h>

int pointer;
int faults ,hits;

void display(int frame_size,int frame[])
{
	int i;
	printf("Available Frame:: ");
	for(i=0;i<frame_size;i++)
	{
		if(frame[i]==-1)
			printf("- ");
		else
			printf("%d ",frame[i]);
	}

	printf("\n");
}

void add_reference(int frame_size,int frame[], int reference)
{
	int i;
	int alloted = 0;
	for(i=0;i<frame_size;i++)
	{
		if(frame[i]==reference)
		{
			alloted = 1;
			printf("  Hit for %d | ", reference);
			hits++;
			break;
		}
		else if(frame[i]==-1)
		{
			alloted = 1;
			frame[i] = reference;
			printf("Fault for %d | ", reference);
			faults++;
			break;
		}
	}
	if(alloted == 0)
	{
		faults++;
		printf("Fault for %d | ", reference);
		frame[pointer] = reference;
		pointer = (pointer+1)%frame_size;
	}
	display(frame_size, frame);
}

int main()
{
	int frame_size,i,number_of_references;
	int reference[100];
	int frame[10];
	printf("Enter frame size: ");
	scanf("%d",&frame_size);
	for(i=0;i<frame_size;i++)
	{
		frame[i] = -1;
	}

	display(frame_size,frame);
	
	printf("Enter the number of references: ");
	scanf("%d",&number_of_references);
	
	for(i=0;i<number_of_references;i++)
	{
		scanf("%d",&reference[i]);
		add_reference(frame_size,frame,reference[i]);
	}
	printf("\nNumber of faults: %d \nNumber of hits: %d\n",faults,hits );
}
----- OR----
#include <stdio.h>

int find(int frame[] , int framesize , int cur) {
	int i;
	for(i = 0; i < framesize; i++) {
		if(cur == frame[i]) return 1;
	}
	return 0;
}

void display(int frame[] , int framesize , int hit) {
	int i;
	for(i = 0; i < framesize; i++) {
		printf("%d | " , frame[i]);
	}
	if(hit == 1) printf("HIT\n");
	else printf("*\n");
}

void fifo(int ref[] ,int framesize , int n) {
	int frame[framesize]; 
	int i;
	for(i = 0; i < framesize; i++) frame[i] = -1;
	
	int hit = 0, pf = 0;
	int rep = 0;
	for(i = 0; i < n; i++) {
		int cur = ref[i];
		if(find(frame , framesize, cur) == 0) {
			pf++;
			frame[rep] = cur;
			rep++;
			if(rep == framesize) rep = 0;
			display(frame , framesize , 0);
		} else {
			hit++;
			display(frame , framesize , 1);
		}
	}
}

int main() {
  int ref[] = {7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1};
  int frameSize = 3;
  int n = 20;
  fifo(ref , frameSize , n);
  return 0;
}


#Q2
//	Write a program to implement the shell. It should display the commandprompt “myshell$”
// Tokenize the command line and execute the given command by creating the child process.
// Additionally it should interpret the following ‘list’ commands as

// myshell$ list f dirname    :- To print names of all the files in current directory.
// myshell$ list n dirname  :- To print the number of all entries in the current directory.
// myshell$ list i dirname : To print names and inodes of the files in the current directory.

#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <dirent.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/wait.h>

void make_toks(char *s, char *tok[])
{
  int i = 0;
  char *p;
  p = strtok(s, " ");
  while (p != NULL)
  {
    tok[i++] = p;
    p = strtok(NULL, " ");
  }
  tok[i] = NULL;
}

void list(char *dn, char op)
{
  DIR *dp;
  struct dirent *entry;
  int dc = 0, fc = 0;
  dp = opendir(dn);
  if (dp == NULL)
  {
    printf("Dir %s not found.\n", dn);
    return;
  }
  switch (op)
  {
  case 'f':
    while (entry = readdir(dp))
      if (entry->d_type == DT_REG)
        printf("%s\n", entry->d_name);
    break;
  case 'n':
    while (entry = readdir(dp))
    {
      if (entry->d_type == DT_DIR)
        dc++;
      if (entry->d_type == DT_REG)
        fc++;
    }
    printf("%d Dir(s)\t%d File(s)\n", dc, fc);
    break;
  case 'i':
    while (entry = readdir(dp))
      if (entry->d_type == DT_REG)
        printf("%s\t%d\n", entry->d_name, entry->d_fileno);
  }
  closedir(dp);
}

int main()
{
  char buff[80], *args[10];
  int pid;
  int status;
  while (1)
  {
    printf("myshell$ ");
    fflush(stdin);
    fgets(buff, 80, stdin);
    buff[strlen(buff) - 1] = '\0';
    make_toks(buff, args);
    if (strcmp(args[0], "list") == 0)
      list(args[2], args[1][0]);
    else
    {
      pid = fork();
      if (pid > 0)
        wait(&status);
      else
        if (execvp(args[0], args) == -1)
          printf("Bad command.\n");
    }
  }
  return 0;
}

