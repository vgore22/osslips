#Q1
#include<stdio.h>
#include<unistd.h>
void display(int array[] , int n) {
	int i = 0;
	for(i = 0; i < n; i++) 
		printf("%d " , array[i]);
	printf("\n");
}
int main() {
	int n , l , i , key , j , a , b; 
	printf("How many numbers: ");
	scanf(" %d" , &n);
	int array[n];
	printf("Enter %d numbers: ", n);
	for(l = 0; l < n; l++)
		scanf(" %d" , &array[l]);
	pid_t pid;
	pid = fork();
	if(pid == 0) {
		// child process 
		printf("\nChild process sorting the array\n");
		for (i = 1; i < n; i++) {
			key = array[i];
			j = i - 1;
			while (j >= 0 && array[j] > key) {
				array[j + 1] = array[j];
				j--;
			}
			array[j + 1] = key;
		}
		display(array , n);
		printf("Child process completed\n");
	} else {
		//parent process
		printf("\nParent process sorting the array\n");
		for(a = 0; a < n; a++) 
			for(b = 0; b < n - a - 1; b++) 
				if(array[b] > array[b + 1]) {
					int temp = array[b];
					array[b] = array[b+1];
					array[b+1] = temp;
				}
		printf("Sorted array: ");
		display(array , n);
		printf("Waiting for child process to finish\n");
		wait(1);
		printf("\nParent terminated\n");
	}
}





#Q2
// Write a C  program to implement the toy shell. It should display the command prompt “myshell$”.
// Tokenize the command line and execute the given command by creating the child process.
// Additionally it should interpret the following commands.
// count c  filename  :- To print number of characters in the file.
// count w  filename   :- To print number of words in the file.
// count l   filename :- To print number of lines in the file.

#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/wait.h>

// seperate sentence: "count c filename" => count , c , filename
void make_toks(char *s, char *tok[])
{
  int i = 0;
  char *p;
  p = strtok(s, " ");
  while (p != NULL)
  {
    tok[i] = p;
    p = strtok(NULL, " ");
    i++;
  }
  tok[i] = NULL;
}

void count(char *fn, char op)
{
  int fh, cc = 0, wc = 0, lc = 0;
  char c;
  fh = open(fn, O_RDONLY);
  if (fh == -1)
  {
    printf("File %s not found.\n", fn);
    return;
  }

  while (read(fh, &c, 1) > 0)
  {
    if (c == ' ')
      wc++;
    else if (c == '\n')
    {
      wc++;
      lc++;
    }
    cc++;
  }

  close(fh);

  switch (op)
  {
  case 'c':
    printf("No.of characters: %d\n", cc);
    break;
  case 'w':
    printf("No.of words: %d\n", wc);
    break;
  case 'l':
    printf("No.of lines: %d\n", lc);
    break;
  }
}

int main()
{
  char buff[80], *args[10];
  int pid;
  int status;
  while (1)
  {
    printf("myshell$ ");
    fflush(stdin);
    fgets(buff, 80, stdin);
    buff[strlen(buff) - 1] = '\0';
    make_toks(buff, args);
    if (strcmp(args[0], "count") == 0)
      count(args[2], args[1][0]);
    else
    {
      pid = fork();
      if (pid > 0)
        wait(&status);
      else
      {
        if (execvp(args[0], args) == -1)
          printf("Bad command.\n");
      }
    }
  }
  return 0;
}

