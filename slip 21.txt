#Q1
#include <stdio.h>
#include <unistd.h>
int main() {
    pid_t pid;
    pid = fork();
    if (pid < 0) {
        printf("Fork failed. Unable to create a child process.\n");
        return 1;
    } else if (pid == 0) {
        printf("I am Child Process\n");
        printf("Child Process ID: %d\n", getpid());
    } else {
        printf("I am Parent Process\n");
        printf("Parent Process ID: %d\n", getpid());
    }
    return 0;
}


#Q2
#include <stdio.h>
#include <stdlib.h>
typedef struct process
{
  int id, at, bt, ct, wt, tat, rt , p;
} process;

void sortID(process pro[], int n)
{
  process temp;
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (pro[j].id > pro[j + 1].id)
      {
        temp = pro[j];
        pro[j] = pro[j + 1];
        pro[j + 1] = temp;
      }
}

void sortP(process pro[], int n)
{
  process temp;
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (pro[j].p > pro[j + 1].p)
      {
        temp = pro[j];
        pro[j] = pro[j + 1];
        pro[j + 1] = temp;
      }
}

void display(process pro[], int n)
{
  printf("\n\nTABLE:\n");
  for (int i = 0; i < n; i++)
  {
    printf("P%d AT: %d BT: %d CT: %d TAT: %d WT: %d\n",
           pro[i].id,
           pro[i].at,
           pro[i].bt,
           pro[i].ct,
           pro[i].tat,
           pro[i].wt);
  }
}

void preemptivePriority(process proc[], int n, int quantum_time)
{
  int j = 0;
  int currentTime = 0;
  int wait_time_total = 0, turn_around_time_total = 0;
  int processes_remaining = n;
  sortP(proc, n);
  while (processes_remaining > 0)
  {
    int min = -1;
    for (j = 0; j < n; j++)
      if (proc[j].at <= currentTime && proc[j].rt > 0)
        if (min == -1 || proc[j].p < proc[min].p)
          min = j;

    if (min == -1)
      currentTime++;
    else if (proc[min].rt > quantum_time)
    {
      proc[min].rt -= quantum_time;
      currentTime += quantum_time;
    }
    else
    {
      currentTime += proc[min].rt;
      proc[min].rt = 0;
      proc[min].ct  = currentTime;
      proc[min].tat = currentTime - proc[min].at;
      proc[min].wt = currentTime - proc[min].at - proc[min].bt;
      turn_around_time_total += proc[min].tat;
      wait_time_total += proc[min].wt;
      processes_remaining--;
    }
  }
  sortID(proc , n);
  display(proc, n);
  printf("\nAvg waiting time: %.2f\nAvg turnaround time: %.2f\n\n", (float)wait_time_total / n, (float)turn_around_time_total / n);
}

int main()
{
  process proc[10];
  int n, i, quantum_time;
  printf("Non Preemptive Priority\n");
  printf("\t(lower p = higher priority)\n\n");
  printf("Enter number of processes: ");
  scanf(" %d", &n);
  for (i = 0; i < n; i++)
  {
    printf("\n");
    proc[i].id = i + 1;
    printf("Arrival time for P%d: ", proc[i].id);
    scanf(" %d", &proc[i].at);
    printf("Burst time for P%d: ", proc[i].id);
    scanf(" %d", &proc[i].bt);
    proc[i].rt = proc[i].bt;
    printf("Pirority for P%d: ", proc[i].id);
    scanf(" %d", &proc[i].p);
  }
  printf("\nEnter time quantum for preemption: ");
  scanf(" %d", &quantum_time);
  preemptivePriority(proc, n, quantum_time);
  return 0;
}
/*
INPUT:
4 0 4 4 1 2 3 2 1 2 3 6 1
*/
